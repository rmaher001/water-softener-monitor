# ESPHome Water Softener Salt Monitor Package
# GitHub: https://github.com/rmaher001/water-softener-monitor
#
# Users reference this file via:
# packages:
#   water_softener: github://rmaher001/water-softener-monitor/src/water-softener-package.yaml@master
#
# Development: Create feature/fix branches and reference them with @branch-name

esp32:
  board: m5stack-atoms3
  variant: esp32s3
  framework:
    type: esp-idf

# Preferences with debounced flash writes to prevent overwhelming the system
preferences:
  flash_write_interval: 5s

# WiFi configuration moved to individual config files
# (water-softener-dev.yaml, water-softener-webinstall.yaml, water-softener.yaml)

# Enable captive portal for WiFi setup (backup method)
captive_portal:

# Enable Improv via Serial for web installer WiFi configuration
improv_serial:

# Enable BLE Improv for wireless WiFi configuration
esp32_improv:
  authorizer: setup_button

# Status LED for BLE Improv feedback (ATOM S3 RGB LED)
light:
  - platform: esp32_rmt_led_strip
    rgb_order: GRB
    pin: GPIO35
    num_leds: 1
    chipset: ws2812
    id: status_led
    name: "Status LED"
    internal: true  # Don't expose to HA

# Enable logging
logger:
  baud_rate: 115200
  deassert_rts_dtr: true  # Required for ESP32-S3 USB CDC compatibility

# API and OTA are configured in individual device files

# Web server for direct browser access
web_server:
  version: 3
  port: 80
  sorting_groups:
    - id: measurement_settings
      name: "Measurement Settings"
      sorting_weight: 10
    - id: alert_thresholds
      name: "Alert Thresholds"
      sorting_weight: 20
    - id: system
      name: "System"
      sorting_weight: 30

# I2C for the ToF sensor (ATOM S3 Lite Grove port)
i2c:
  sda: GPIO2
  scl: GPIO1
  scan: true

# Global variables

globals:
  - id: last_update_time
    type: unsigned long
    restore_value: no
    initial_value: '0'

  - id: last_valid_percentage
    type: float
    restore_value: yes
    initial_value: '0.0'

  - id: last_valid_status
    type: std::string
    restore_value: yes
    initial_value: '"Checking..."'



# Configurable settings

number:

  # Measurement settings

  - platform: template
    name: "Tank Height"
    id: tank_height_cm
    optimistic: true
    restore_value: true
    initial_value: 100
    min_value: 30
    max_value: 150
    step: 1
    unit_of_measurement: "cm"
    icon: "mdi:arrow-expand-vertical"
    mode: box
    web_server:
      sorting_group_id: measurement_settings
    on_value:
      then:
        - component.update: salt_level_percent



  - platform: template
    name: "Full Level Distance"
    id: full_level_cm
    optimistic: true
    restore_value: true
    initial_value: 20
    min_value: 5
    max_value: 50
    step: 1
    unit_of_measurement: "cm"
    icon: "mdi:arrow-collapse-down"
    mode: box
    web_server:
      sorting_group_id: measurement_settings
    on_value:
      then:
        - component.update: salt_level_percent



  - platform: template
    name: "Update Interval"
    id: update_interval_seconds
    optimistic: true
    restore_value: true
    initial_value: 20
    min_value: 1
    max_value: 86400
    step: 1
    unit_of_measurement: "s"
    icon: "mdi:timer"
    mode: box
    web_server:
      sorting_group_id: measurement_settings



  # Alert thresholds

  - platform: template
    name: "Critical Alert Threshold"
    id: critical_threshold
    optimistic: true
    restore_value: true
    initial_value: 20
    min_value: 0
    max_value: 100
    step: 5
    unit_of_measurement: "%"
    icon: "mdi:alert-octagon"
    mode: slider
    web_server:
      sorting_group_id: alert_thresholds
    on_value:
      then:
        - component.update: salt_status_text



  - platform: template
    name: "Full Threshold"
    id: full_threshold
    optimistic: true
    restore_value: true
    initial_value: 80
    min_value: 0
    max_value: 100
    step: 5
    unit_of_measurement: "%"
    icon: "mdi:check-circle"
    mode: slider
    web_server:
      sorting_group_id: alert_thresholds
    on_value:
      then:
        - component.update: salt_status_text



  - platform: template
    name: "Good Threshold"
    id: good_threshold
    optimistic: true
    restore_value: true
    initial_value: 60
    min_value: 0
    max_value: 100
    step: 5
    unit_of_measurement: "%"
    icon: "mdi:check"
    mode: slider
    web_server:
      sorting_group_id: alert_thresholds
    on_value:
      then:
        - component.update: salt_status_text



  - platform: template
    name: "Low Alert Threshold"
    id: low_threshold
    optimistic: true
    restore_value: true
    initial_value: 40
    min_value: 0
    max_value: 100
    step: 5
    unit_of_measurement: "%"
    icon: "mdi:alert"
    mode: slider
    web_server:
      sorting_group_id: alert_thresholds
    on_value:
      then:
        - component.update: salt_status_text

# Calibration mode switch
switch:
  - platform: template
    name: "Calibration Mode"
    id: calibration_mode
    icon: "mdi:ruler"
    optimistic: true
    web_server:
      sorting_group_id: system
    on_turn_on:
      - delay: 300s  # 5 minutes
      - switch.turn_off: calibration_mode

# Buttons
button:
  - platform: template
    name: "Reset to Defaults"
    icon: "mdi:restore"
    web_server:
      sorting_group_id: measurement_settings
    on_press:
      - number.set:
          id: tank_height_cm
          value: 100
      - delay: 100ms
      - number.set:
          id: full_level_cm
          value: 20
      - delay: 100ms
      - number.set:
          id: update_interval_seconds
          value: 20
      - delay: 100ms
      - number.set:
          id: full_threshold
          value: 80
      - delay: 100ms
      - number.set:
          id: good_threshold
          value: 60
      - delay: 100ms
      - number.set:
          id: low_threshold
          value: 40
      - delay: 100ms
      - number.set:
          id: critical_threshold
          value: 20

  - platform: restart
    name: "Restart"
    icon: "mdi:restart"
    web_server:
      sorting_group_id: system

# VL53L0X Distance Sensor
sensor:
  - platform: vl53l0x
    name: "Distance to Salt"
    id: salt_distance_raw
    address: 0x29
    update_interval: never  # Controlled by interval component below
    long_range: true
    unit_of_measurement: "cm"
    accuracy_decimals: 1
    filters:
      - multiply: 100  # Convert meters to cm
      - filter_out: nan
      - sliding_window_moving_average:
          window_size: 10
          send_every: 1
    on_value:
      then:
        - component.update: salt_level_percent
        - component.update: salt_status_text

  # Calculate salt level percentage
  - platform: template
    name: "Salt Level"
    id: salt_level_percent
    unit_of_measurement: "%"
    icon: "mdi:water-percent"
    accuracy_decimals: 0
    update_interval: never  # Only updates when triggered
    lambda: |-
      // VL53L0X sensor hardware limits
      const float SENSOR_MIN_RANGE = 3.0;   // cm
      const float SENSOR_MAX_RANGE = 150.0; // cm

      float tank_height = id(tank_height_cm).state;
      float full_level = id(full_level_cm).state;
      float current_distance = id(salt_distance_raw).state;

      // Check if sensor reading is valid
      bool is_valid = true;
      if (isnan(current_distance) || isnan(tank_height) || isnan(full_level)) {
        is_valid = false;
      } else if (current_distance < SENSOR_MIN_RANGE) {
        is_valid = false;
      } else if (current_distance > SENSOR_MAX_RANGE) {
        is_valid = false;
      }

      if (!is_valid) {
        // Return last valid value
        return id(last_valid_percentage);
      }

      // Calculate percentage
      float salt_height = tank_height - current_distance;
      float max_salt_height = tank_height - full_level;
      float percentage = (salt_height / max_salt_height) * 100.0;

      // Clamp to 0-100%
      if (percentage > 100.0) percentage = 100.0;
      if (percentage < 0.0) percentage = 0.0;

      // Store and return valid value
      id(last_valid_percentage) = percentage;
      return percentage;

  # WiFi signal strength
  - platform: wifi_signal
    name: "WiFi Signal"
    update_interval: 60s
    icon: "mdi:wifi"
    web_server:
      sorting_group_id: system

# Binary sensors
binary_sensor:
  # Button for BLE Improv authorization (ATOM S3 button on GPIO41)
  - platform: gpio
    pin:
      number: GPIO41
      inverted: true
      mode: INPUT_PULLUP
    name: "Setup Button"
    id: setup_button
    filters:
      - delayed_on: 10ms
      - delayed_off: 10ms

  - platform: template
    name: "Sensor Out of Range"
    id: sensor_out_of_range
    icon: "mdi:alert-circle"
    web_server:
      sorting_group_id: system
    lambda: |-
      // VL53L0X sensor hardware limits
      const float SENSOR_MIN_RANGE = 3.0;   // cm
      const float SENSOR_MAX_RANGE = 150.0; // cm

      float tank_height = id(tank_height_cm).state;
      float full_level = id(full_level_cm).state;
      float current_distance = id(salt_distance_raw).state;

      // Check if reading is invalid
      if (isnan(current_distance) || isnan(tank_height) || isnan(full_level)) {
        return true;
      } else if (current_distance < SENSOR_MIN_RANGE) {
        return true;
      } else if (current_distance > SENSOR_MAX_RANGE) {
        return true;
      }
      return false;  // Valid reading

# Status text
text_sensor:
  - platform: template
    name: "Salt Status"
    id: salt_status_text
    icon: "mdi:information-variant"
    update_interval: never  # Only updates when triggered
    lambda: |-
      float level = id(salt_level_percent).state;
      float full_threshold_val = id(full_threshold)->state;
      float good_threshold_val = id(good_threshold)->state;
      float low_threshold_val = id(low_threshold)->state;
      float critical_threshold_val = id(critical_threshold)->state;

      std::string status;
      if (isnan(level)) {
        status = "Checking...";
      } else if (level >= full_threshold_val) {
        status = "Full";
      } else if (level >= good_threshold_val) {
        status = "Good";
      } else if (level >= low_threshold_val) {
        status = "Low - Add Salt Soon";
      } else if (level >= critical_threshold_val) {
        status = "Critical - Add Salt NOW!";
      } else {
        status = "Critical - Add Salt NOW!";
      }

      // Store last valid status
      id(last_valid_status) = status;
      return {status};

# Fast update interval for calibration mode
interval:
  - interval: 100ms
    then:
      - if:
          condition:
            switch.is_on: calibration_mode
          then:
            - component.update: salt_distance_raw

  # Normal update interval check
  - interval: 1s
    then:
      - lambda: |-
          // Only run normal interval if NOT in calibration mode
          if (!id(calibration_mode).state) {
            unsigned long current_time = millis() / 1000;
            unsigned long interval_sec = (unsigned long)id(update_interval_seconds).state;

            if (current_time - id(last_update_time) >= interval_sec) {
              id(last_update_time) = current_time;
              id(salt_distance_raw).update();
            }
          }
