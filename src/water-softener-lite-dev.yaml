# Water Softener Monitor - ATOM Lite (ESP32-PICO) Config
# For M5Stack ATOM Lite with VL53L0X sensor
# This is a test/development config - NOT for web installer

substitutions:
  name: "water-softener-atom-lite"
  version: "1.2.20-atomlite-idf"

esphome:
  name: "${name}"
  friendly_name: Water Softener ATOM Lite
  comment: Water Softener Monitor (ATOM Lite)
  name_add_mac_suffix: false
  project:
    name: "rmaher001.water-softener-monitor"
    version: "${version}"

# ATOM Lite specific board config - Testing ESP-IDF
esp32:
  board: m5stack-atom
  framework:
    type: esp-idf

# Preferences with debounced flash writes
preferences:
  flash_write_interval: 5s

# Enable logging
logger:
  baud_rate: 115200

# API for Home Assistant integration
api:

# OTA updates
ota:
  - platform: esphome

# WiFi configuration
wifi:
  ssid: !secret wifi_ssid
  password: !secret wifi_password
  power_save_mode: none
  ap:
    ssid: "ATOM Lite Hotspot"
    password: "configme123"
    ap_timeout: 0s

# Enable captive portal
captive_portal:

# Web server for configuration (testing with ESP-IDF)
web_server:
  port: 80
  version: 3

# Enable Improv for wireless WiFi configuration
improv_serial:

esp32_improv:
  authorizer: none

# I2C Configuration - ATOM Lite Grove port pins (GPIO26/GPIO32)
i2c:
  sda: GPIO26
  scl: GPIO32
  scan: true

# Global variables
globals:
  - id: last_update_time
    type: unsigned long
    restore_value: no
    initial_value: '0'

  - id: last_valid_percentage
    type: float
    restore_value: yes
    initial_value: '0.0'

  - id: last_valid_status
    type: std::string
    restore_value: yes
    initial_value: '"Checking..."'

# Configurable settings
number:
  # Measurement settings
  - platform: template
    name: "Tank Height"
    id: tank_height_cm
    entity_category: "config"
    optimistic: true
    restore_value: true
    initial_value: 100
    min_value: 30
    max_value: 150
    step: 1
    unit_of_measurement: "cm"
    icon: "mdi:arrow-expand-vertical"
    mode: box
    on_value:
      then:
        - component.update: salt_level_percent

  - platform: template
    name: "Full Level Distance"
    id: full_level_cm
    entity_category: "config"
    optimistic: true
    restore_value: true
    initial_value: 20
    min_value: 5
    max_value: 50
    step: 1
    unit_of_measurement: "cm"
    icon: "mdi:arrow-collapse-down"
    mode: box
    on_value:
      then:
        - component.update: salt_level_percent

  - platform: template
    name: "Update Interval"
    id: update_interval_seconds
    entity_category: "config"
    optimistic: true
    restore_value: true
    initial_value: 20
    min_value: 1
    max_value: 86400
    step: 1
    unit_of_measurement: "s"
    icon: "mdi:timer"
    mode: box

  # Alert thresholds
  - platform: template
    name: "Critical Alert Threshold"
    id: critical_threshold
    entity_category: "config"
    optimistic: true
    restore_value: true
    initial_value: 20
    min_value: 0
    max_value: 100
    step: 5
    unit_of_measurement: "%"
    icon: "mdi:alert-octagon"
    mode: slider
    on_value:
      then:
        - component.update: salt_status_text

  - platform: template
    name: "Full Threshold"
    id: full_threshold
    entity_category: "config"
    optimistic: true
    restore_value: true
    initial_value: 80
    min_value: 0
    max_value: 100
    step: 5
    unit_of_measurement: "%"
    icon: "mdi:check-circle"
    mode: slider
    on_value:
      then:
        - component.update: salt_status_text

  - platform: template
    name: "Good Threshold"
    id: good_threshold
    entity_category: "config"
    optimistic: true
    restore_value: true
    initial_value: 60
    min_value: 0
    max_value: 100
    step: 5
    unit_of_measurement: "%"
    icon: "mdi:check"
    mode: slider
    on_value:
      then:
        - component.update: salt_status_text

  - platform: template
    name: "Low Alert Threshold"
    id: low_threshold
    entity_category: "config"
    optimistic: true
    restore_value: true
    initial_value: 40
    min_value: 0
    max_value: 100
    step: 5
    unit_of_measurement: "%"
    icon: "mdi:alert"
    mode: slider
    on_value:
      then:
        - component.update: salt_status_text

# Calibration mode switch
switch:
  - platform: template
    name: "Calibration Mode"
    id: calibration_mode
    icon: "mdi:ruler"
    optimistic: true
    on_turn_on:
      - delay: 300s  # 5 minutes
      - switch.turn_off: calibration_mode

# Buttons
button:
  - platform: template
    name: "Reset Thresholds to Defaults"
    icon: "mdi:restore"
    on_press:
      - number.set:
          id: full_threshold
          value: 80
      - delay: 100ms
      - number.set:
          id: good_threshold
          value: 60
      - delay: 100ms
      - number.set:
          id: low_threshold
          value: 40
      - delay: 100ms
      - number.set:
          id: critical_threshold
          value: 20

  - platform: restart
    name: "Restart"
    icon: "mdi:restart"

# VL53L0X Distance Sensor
sensor:
  - platform: vl53l0x
    name: "Distance to Salt"
    id: salt_distance_raw
    address: 0x29
    update_interval: never  # Controlled by interval component
    long_range: true
    unit_of_measurement: "cm"
    accuracy_decimals: 1
    filters:
      - multiply: 100  # Convert meters to cm
      - filter_out: nan
      - sliding_window_moving_average:
          window_size: 10
          send_every: 1
    on_value:
      then:
        - component.update: salt_level_percent
        - component.update: salt_status_text

  # Calculate salt level percentage
  - platform: template
    name: "Salt Level"
    id: salt_level_percent
    unit_of_measurement: "%"
    icon: "mdi:water-percent"
    accuracy_decimals: 0
    update_interval: never
    lambda: |-
      // VL53L0X sensor hardware limits
      const float SENSOR_MIN_RANGE = 3.0;   // cm
      const float SENSOR_MAX_RANGE = 150.0; // cm

      float tank_height = id(tank_height_cm).state;
      float full_level = id(full_level_cm).state;
      float current_distance = id(salt_distance_raw).state;

      // Check if sensor reading is valid
      bool is_valid = true;
      if (isnan(current_distance) || isnan(tank_height) || isnan(full_level)) {
        is_valid = false;
      } else if (current_distance < SENSOR_MIN_RANGE) {
        is_valid = false;
      } else if (current_distance > SENSOR_MAX_RANGE) {
        is_valid = false;
      }

      if (!is_valid) {
        // Return last valid value
        return id(last_valid_percentage);
      }

      // Calculate percentage
      float salt_height = tank_height - current_distance;
      float max_salt_height = tank_height - full_level;
      float percentage = (salt_height / max_salt_height) * 100.0;

      // Clamp to 0-100%
      if (percentage > 100.0) percentage = 100.0;
      if (percentage < 0.0) percentage = 0.0;

      // Store and return valid value
      id(last_valid_percentage) = percentage;
      return percentage;

  # WiFi signal strength
  - platform: wifi_signal
    name: "WiFi Signal"
    update_interval: 60s
    icon: "mdi:wifi"

# Binary sensors
binary_sensor:
  # Button for ATOM Lite (GPIO39)
  - platform: gpio
    pin:
      number: GPIO39
      inverted: true
      mode: INPUT
    name: "Setup Button"
    id: setup_button
    filters:
      - delayed_on: 10ms
      - delayed_off: 10ms

  - platform: template
    name: "Sensor Out of Range"
    id: sensor_out_of_range
    icon: "mdi:alert-circle"
    lambda: |-
      // VL53L0X sensor hardware limits
      const float SENSOR_MIN_RANGE = 3.0;   // cm
      const float SENSOR_MAX_RANGE = 150.0; // cm

      float tank_height = id(tank_height_cm).state;
      float full_level = id(full_level_cm).state;
      float current_distance = id(salt_distance_raw).state;

      // Check if reading is invalid
      if (isnan(current_distance) || isnan(tank_height) || isnan(full_level)) {
        return true;
      } else if (current_distance < SENSOR_MIN_RANGE) {
        return true;
      } else if (current_distance > SENSOR_MAX_RANGE) {
        return true;
      }
      return false;  // Valid reading

# Status text
text_sensor:
  - platform: template
    name: "Salt Status"
    id: salt_status_text
    icon: "mdi:information-variant"
    update_interval: never
    lambda: |-
      float level = id(salt_level_percent).state;
      float full_threshold_val = id(full_threshold)->state;
      float good_threshold_val = id(good_threshold)->state;
      float low_threshold_val = id(low_threshold)->state;
      float critical_threshold_val = id(critical_threshold)->state;

      std::string status;
      if (isnan(level)) {
        status = "Checking...";
      } else if (level >= full_threshold_val) {
        status = "Full";
      } else if (level >= good_threshold_val) {
        status = "Good";
      } else if (level >= low_threshold_val) {
        status = "Low - Add Salt Soon";
      } else if (level >= critical_threshold_val) {
        status = "Critical - Add Salt NOW!";
      } else {
        status = "Critical - Add Salt NOW!";
      }

      // Store last valid status
      id(last_valid_status) = status;
      return {status};

# Fast update interval for calibration mode
interval:
  - interval: 100ms
    then:
      - if:
          condition:
            switch.is_on: calibration_mode
          then:
            - component.update: salt_distance_raw

  # Normal update interval check
  - interval: 1s
    then:
      - lambda: |-
          // Only run normal interval if NOT in calibration mode
          if (!id(calibration_mode).state) {
            unsigned long current_time = millis() / 1000;
            unsigned long interval_sec = (unsigned long)id(update_interval_seconds).state;

            if (current_time - id(last_update_time) >= interval_sec) {
              id(last_update_time) = current_time;
              id(salt_distance_raw).update();
            }
          }
