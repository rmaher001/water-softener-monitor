# ESPHome Water Softener Salt Monitor - Simplified v0.3
# GitHub: https://github.com/rmaher001/water-softener-monitor
#
# Simple distance-based monitoring with basic Good/Refill status
# All advanced analytics handled in Home Assistant

esp32:
  board: m5stack-atoms3
  variant: esp32s3
  framework:
    type: esp-idf

# Preferences with debounced flash writes
preferences:
  flash_write_interval: 5s

# WiFi configuration moved to individual config files
captive_portal:

# Enable Improv via Serial for web installer WiFi configuration
improv_serial:

# Enable BLE Improv for wireless WiFi configuration
esp32_improv:
  authorizer: none

# Enable logging
logger:
  baud_rate: 115200
  deassert_rts_dtr: true  # Required for ESP32-S3 USB CDC compatibility

# Web server for standalone configuration
web_server:
  port: 80
  version: 3

# I2C for the ToF sensor (ATOM S3 Lite Grove port)
i2c:
  sda: GPIO2
  scl: GPIO1
  scan: true

# RGB LED (ATOM S3 built-in) - kept for future use
light:
  - platform: esp32_rmt_led_strip
    id: status_led
    name: "Status LED"
    internal: true
    pin: GPIO35
    num_leds: 1
    rgb_order: GRB
    chipset: SK6812

# Global variables
globals:
  - id: last_valid_status
    type: std::string
    restore_value: yes
    initial_value: '"Checking..."'

  # Regeneration detection tracking
  - id: regen_active
    type: bool
    restore_value: no
    initial_value: 'false'

  - id: regen_baseline
    type: float
    restore_value: no
    initial_value: '0.0'

  - id: regen_start_time
    type: unsigned long
    restore_value: no
    initial_value: '0'

  - id: drop_amount
    type: float
    restore_value: no
    initial_value: '0.0'

  - id: recent_readings
    type: std::vector<float>
    restore_value: no

# Configurable settings
number:
  - platform: template
    name: "Tank Height"
    id: tank_height_cm
    entity_category: "config"
    optimistic: true
    restore_value: true
    initial_value: 82
    min_value: 30
    max_value: 150
    step: 1
    unit_of_measurement: "cm"
    icon: "mdi:arrow-expand-vertical"
    mode: box

  - platform: template
    name: "Refill Threshold Distance"
    id: refill_threshold_cm
    entity_category: "config"
    optimistic: true
    restore_value: true
    initial_value: 35
    min_value: 10
    max_value: 120
    step: 1
    unit_of_measurement: "cm"
    icon: "mdi:arrow-expand-down"
    mode: box

  - platform: template
    name: "Update Interval"
    id: update_interval_seconds
    entity_category: "config"
    optimistic: true
    restore_value: true
    initial_value: 60
    min_value: 30
    max_value: 300
    step: 30
    unit_of_measurement: "s"
    icon: "mdi:timer-outline"
    mode: box

# Switches
switch:
  - platform: template
    name: "Fast Polling Mode"
    id: fast_polling_mode
    icon: "mdi:speedometer"
    optimistic: true
    on_turn_on:
      - delay: 300s  # Auto-disable after 5 minutes
      - switch.turn_off: fast_polling_mode

# Buttons
button:
  - platform: restart
    name: "Restart"
    icon: "mdi:restart"

# VL53L0X Distance Sensor
sensor:
  - platform: vl53l0x
    name: "Distance to Salt"
    id: salt_distance_raw
    address: 0x29
    update_interval: never  # Controlled by interval component
    long_range: true
    unit_of_measurement: "cm"
    accuracy_decimals: 1
    filters:
      - multiply: 100  # Convert meters to cm
      - filter_out: nan
      - clamp:
          min_value: 5.0
          max_value: 120.0
          ignore_out_of_range: true
      - median:
          window_size: 3
          send_every: 1
    on_value:
      then:
        - component.update: salt_status_text

  # WiFi signal strength
  - platform: wifi_signal
    name: "WiFi Signal"
    update_interval: 60s
    icon: "mdi:wifi"

# Binary sensors
binary_sensor:
  # Setup button (ATOM S3)
  - platform: gpio
    pin:
      number: GPIO41
      inverted: true
      mode: INPUT_PULLUP
    name: "Setup Button"
    id: setup_button
    internal: true
    filters:
      - delayed_on: 10ms
      - delayed_off: 10ms

  - platform: template
    name: "Sensor Out of Range"
    id: sensor_out_of_range
    icon: "mdi:alert-circle"
    lambda: |-
      const float SENSOR_MIN_RANGE = 5.0;   // cm
      const float SENSOR_MAX_RANGE = 120.0; // cm
      float current_distance = id(salt_distance_raw).state;

      if (isnan(current_distance)) {
        return true;
      } else if (current_distance < SENSOR_MIN_RANGE || current_distance > SENSOR_MAX_RANGE) {
        return true;
      }
      return false;

  - platform: template
    name: "Regeneration Cycle Active"
    id: regen_cycle_active
    icon: "mdi:water-sync"
    lambda: |-
      float current_distance = id(salt_distance_raw).state;
      unsigned long current_time = millis();

      if (isnan(current_distance)) {
        return id(regen_active);
      }

      // === START DETECTION ===
      if (!id(regen_active)) {
        bool start_detected = false;

        // Check for >3cm rise over last 5 readings
        // (Faster detection at shorter update intervals, still works at longer intervals)
        if (id(recent_readings).size() >= 5) {
          float rise_5readings = current_distance - id(recent_readings)[id(recent_readings).size() - 5];
          if (rise_5readings > 3.0) {
            start_detected = true;
            ESP_LOGD("regen", "Rise over 5 readings: %.1fcm", rise_5readings);
          }
        }

        // Check for >5cm rise over last 10 readings (catches slower/gradual rises)
        if (!start_detected && id(recent_readings).size() >= 10) {
          float rise_10readings = current_distance - id(recent_readings)[id(recent_readings).size() - 10];
          if (rise_10readings > 5.0) {
            start_detected = true;
            ESP_LOGD("regen", "Rise over 10 readings: %.1fcm", rise_10readings);
          }
        }

        if (start_detected) {
          id(regen_active) = true;
          id(regen_baseline) = id(recent_readings).front();
          id(regen_start_time) = current_time;
          id(drop_amount) = current_distance - id(regen_baseline);
          ESP_LOGI("regen", "Regeneration started - baseline: %.1fcm, rise: %.1fcm",
                   id(regen_baseline), id(drop_amount));
        }
      }

      // Maintain rolling window of recent readings (keeps last 60 samples)
      // Provides sufficient history for rise detection and stability checks
      if (id(recent_readings).size() >= 60) {
        id(recent_readings).erase(id(recent_readings).begin());
      }
      id(recent_readings).push_back(current_distance);

      // === END DETECTION ===
      if (id(regen_active)) {
        unsigned long elapsed_seconds = (current_time - id(regen_start_time)) / 1000;
        unsigned long elapsed_minutes = elapsed_seconds / 60;
        float current_rise = current_distance - id(regen_baseline);

        // Safety timeout: 4 hours
        if (elapsed_minutes > 240) {
          ESP_LOGI("regen", "Regeneration ended - timeout after %lu minutes", elapsed_minutes);
          id(regen_active) = false;
          id(recent_readings).clear();
          return false;
        }

        // False alarm reset: <5cm total rise after 1 hour
        if (elapsed_minutes > 60 && id(drop_amount) < 5.0) {
          ESP_LOGI("regen", "Regeneration ended - false alarm (only %.1fcm rise)", id(drop_amount));
          id(regen_active) = false;
          id(recent_readings).clear();
          return false;
        }

        // End condition: 50% recovery + stability check
        // Requires distance to recover halfway back to baseline AND remain stable
        float recovery_target = id(regen_baseline) + (id(drop_amount) * 0.5);
        bool recovered = current_distance <= recovery_target;

        // Check stability over last 30 readings (sufficient sample size across all update intervals)
        if (recovered && id(recent_readings).size() >= 30) {
          float min_distance = *std::min_element(id(recent_readings).begin(), id(recent_readings).end());
          float max_distance = *std::max_element(id(recent_readings).begin(), id(recent_readings).end());
          float variation = max_distance - min_distance;

          if (variation <= 2.0) {
            ESP_LOGI("regen", "Regeneration ended - recovered and stable after %lu minutes", elapsed_minutes);
            id(regen_active) = false;
            id(recent_readings).clear();
            return false;
          }
        }

        if (current_rise > id(drop_amount)) {
          id(drop_amount) = current_rise;
        }
      }

      return id(regen_active);

# Status text
text_sensor:
  - platform: template
    name: "Salt Status"
    id: salt_status_text
    icon: "mdi:information-variant"
    update_interval: never
    lambda: |-
      // Freeze status during regeneration cycle
      if (id(regen_active)) {
        return {id(last_valid_status)};
      }

      float distance = id(salt_distance_raw).state;
      float threshold = id(refill_threshold_cm).state;
      const float HYSTERESIS = 2.0; // cm

      std::string new_status;
      std::string current_status = id(last_valid_status);

      if (isnan(distance)) {
        new_status = "Checking...";
      } else {
        // Apply hysteresis based on current status
        if (current_status == "Good") {
          // Need to exceed threshold + hysteresis to change to Refill
          if (distance >= (threshold + HYSTERESIS)) {
            new_status = "Refill";
          } else {
            new_status = "Good";
          }
        } else {
          // Currently "Refill" or "Checking..." - need to drop below threshold - hysteresis for Good
          if (distance < (threshold - HYSTERESIS)) {
            new_status = "Good";
          } else {
            new_status = "Refill";
          }
        }
      }

      id(last_valid_status) = new_status;
      return {new_status};

  - platform: template
    name: "Firmware Version"
    icon: "mdi:chip"
    lambda: |-
      return {"${version}"};

# Update intervals
interval:
  # Fast polling for setup/calibration
  - interval: 100ms
    then:
      - if:
          condition:
            switch.is_on: fast_polling_mode
          then:
            - component.update: salt_distance_raw

  # Normal update interval
  - interval: 1s
    then:
      - lambda: |-
          static unsigned long last_update = 0;
          unsigned long current_time = millis() / 1000;
          unsigned long interval_sec = (unsigned long)id(update_interval_seconds).state;

          if (!id(fast_polling_mode).state && (current_time - last_update >= interval_sec)) {
            last_update = current_time;
            id(salt_distance_raw).update();
          }

# On boot - take immediate reading
esphome:
  on_boot:
    priority: -100  # After other components initialized
    then:
      - delay: 2s  # Wait for sensor to stabilize
      - component.update: salt_distance_raw
