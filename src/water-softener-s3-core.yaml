# ESPHome Water Softener Salt Monitor Package
# GitHub: https://github.com/rmaher001/water-softener-monitor
#
# Users reference this file via:
# packages:
#   water_softener: github://rmaher001/water-softener-monitor/src/water-softener-package.yaml@master
#
# Development: Create feature/fix branches and reference them with @branch-name

esp32:
  board: m5stack-atoms3
  variant: esp32s3
  framework:
    type: arduino

# Preferences with debounced flash writes to prevent overwhelming the system
preferences:
  flash_write_interval: 5s


# WiFi configuration moved to individual config files
# (water-softener-dev.yaml, water-softener-webinstall.yaml, water-softener.yaml)

# Enable captive portal for WiFi setup (backup method)
captive_portal:

# Enable Improv via Serial for web installer WiFi configuration
improv_serial:

# Enable BLE Improv for wireless WiFi configuration
# Uses 'none' authorizer - makes it easier for users during initial web installer setup
# Security comes from eventual ESPHome Dashboard adoption with encryption
esp32_improv:
  authorizer: none

# Enable logging
logger:
  baud_rate: 115200
  deassert_rts_dtr: true  # Required for ESP32-S3 USB CDC compatibility

# API and OTA are configured in individual device files

# Web server disabled due to Arduino framework socket exhaustion (error 23)
# - Arduino framework needed for NVS persistence on ESP32-S3
# - Arduino has limited sockets (10-16) that can't be increased via config
# - Web server exhausts sockets causing API/OTA failures and crashes
# - Users can configure via Home Assistant UI instead
# - To fix: would need ESP-IDF + increased CONFIG_LWIP_MAX_SOCKETS, but ESP-IDF breaks persistence

# I2C for the ToF sensor (ATOM S3 Lite Grove port)
i2c:
  sda: GPIO2
  scl: GPIO1
  scan: true

# Global variables

globals:
  - id: last_update_time
    type: unsigned long
    restore_value: no
    initial_value: '0'

  - id: last_valid_percentage
    type: float
    restore_value: yes
    initial_value: '0.0'

  - id: last_valid_status
    type: std::string
    restore_value: yes
    initial_value: '"Checking..."'

  # Status change delay tracking
  - id: pending_status
    type: std::string
    restore_value: no
    initial_value: '""'

  - id: pending_status_time
    type: unsigned long
    restore_value: no
    initial_value: '0'

  # Regeneration detection tracking
  - id: regen_active
    type: bool
    restore_value: no
    initial_value: 'false'

  - id: regen_baseline
    type: float
    restore_value: no
    initial_value: '0.0'

  - id: regen_start_time
    type: unsigned long
    restore_value: no
    initial_value: '0'

  - id: drop_amount
    type: float
    restore_value: no
    initial_value: '0.0'

  - id: recent_readings
    type: std::vector<float>
    restore_value: no



# Configurable settings

number:

  # Measurement settings

  - platform: template
    name: "Tank Height"
    id: tank_height_cm
    entity_category: "config"
    optimistic: true
    restore_value: true
    initial_value: 100
    min_value: 30
    max_value: 150
    step: 1
    unit_of_measurement: "cm"
    icon: "mdi:arrow-expand-vertical"
    mode: box
    on_value:
      then:
        - component.update: salt_level_percent



  - platform: template
    name: "Full Level Distance"
    id: full_level_cm
    entity_category: "config"
    optimistic: true
    restore_value: true
    initial_value: 20
    min_value: 5
    max_value: 50
    step: 1
    unit_of_measurement: "cm"
    icon: "mdi:arrow-collapse-down"
    mode: box
    on_value:
      then:
        - component.update: salt_level_percent



  - platform: template
    name: "Update Interval"
    id: update_interval_seconds
    entity_category: "config"
    optimistic: true
    restore_value: true
    initial_value: 300
    min_value: 1
    max_value: 86400
    step: 1
    unit_of_measurement: "s"
    icon: "mdi:timer"
    mode: box



  # Alert thresholds

  - platform: template
    name: "Critical Alert Threshold"
    id: critical_threshold
    entity_category: "config"
    optimistic: true
    restore_value: true
    initial_value: 20
    min_value: 0
    max_value: 100
    step: 5
    unit_of_measurement: "%"
    icon: "mdi:alert-octagon"
    mode: slider
    on_value:
      then:
        - component.update: salt_status_text



  - platform: template
    name: "Full Threshold"
    id: full_threshold
    entity_category: "config"
    optimistic: true
    restore_value: true
    initial_value: 80
    min_value: 0
    max_value: 100
    step: 5
    unit_of_measurement: "%"
    icon: "mdi:check-circle"
    mode: slider
    on_value:
      then:
        - component.update: salt_status_text



  - platform: template
    name: "Good Threshold"
    id: good_threshold
    entity_category: "config"
    optimistic: true
    restore_value: true
    initial_value: 60
    min_value: 0
    max_value: 100
    step: 5
    unit_of_measurement: "%"
    icon: "mdi:check"
    mode: slider
    on_value:
      then:
        - component.update: salt_status_text



  - platform: template
    name: "Low Alert Threshold"
    id: low_threshold
    entity_category: "config"
    optimistic: true
    restore_value: true
    initial_value: 40
    min_value: 0
    max_value: 100
    step: 5
    unit_of_measurement: "%"
    icon: "mdi:alert"
    mode: slider
    on_value:
      then:
        - component.update: salt_status_text

# Calibration mode switch
switch:
  - platform: template
    name: "Calibration Mode"
    id: calibration_mode
    icon: "mdi:ruler"
    optimistic: true
    on_turn_on:
      - delay: 300s  # 5 minutes
      - switch.turn_off: calibration_mode

# Buttons
button:
  - platform: template
    name: "Reset Thresholds to Defaults"
    icon: "mdi:restore"
    on_press:
      - number.set:
          id: full_threshold
          value: 80
      - delay: 100ms
      - number.set:
          id: good_threshold
          value: 60
      - delay: 100ms
      - number.set:
          id: low_threshold
          value: 40
      - delay: 100ms
      - number.set:
          id: critical_threshold
          value: 20

  - platform: restart
    name: "Restart"
    icon: "mdi:restart"

# VL53L0X Distance Sensor
sensor:
  - platform: vl53l0x
    name: "Distance to Salt"
    id: salt_distance_raw
    address: 0x29
    update_interval: never  # Controlled by interval component below
    long_range: true
    unit_of_measurement: "cm"
    accuracy_decimals: 1
    filters:
      - multiply: 100  # Convert meters to cm
      - filter_out: nan
      - median:
          window_size: 5
          send_every: 1
    on_value:
      then:
        - component.update: salt_level_percent
        - component.update: salt_status_text
        - component.update: regen_cycle_active

  # Calculate salt level percentage
  - platform: template
    name: "Salt Level"
    id: salt_level_percent
    unit_of_measurement: "%"
    icon: "mdi:water-percent"
    accuracy_decimals: 0
    update_interval: never  # Only updates when triggered
    lambda: |-
      // VL53L0X sensor hardware limits
      const float SENSOR_MIN_RANGE = 3.0;   // cm
      const float SENSOR_MAX_RANGE = 150.0; // cm

      float tank_height = id(tank_height_cm).state;
      float full_level = id(full_level_cm).state;
      float current_distance = id(salt_distance_raw).state;

      // Check if sensor reading is valid
      bool is_valid = true;
      if (isnan(current_distance) || isnan(tank_height) || isnan(full_level)) {
        is_valid = false;
      } else if (current_distance < SENSOR_MIN_RANGE) {
        is_valid = false;
      } else if (current_distance > SENSOR_MAX_RANGE) {
        is_valid = false;
      }

      if (!is_valid) {
        // Return last valid value
        return id(last_valid_percentage);
      }

      // Calculate percentage
      float salt_height = tank_height - current_distance;
      float max_salt_height = tank_height - full_level;
      float percentage = (salt_height / max_salt_height) * 100.0;

      // Clamp to 0-100%
      if (percentage > 100.0) percentage = 100.0;
      if (percentage < 0.0) percentage = 0.0;

      // Store and return valid value
      id(last_valid_percentage) = percentage;
      return percentage;

  # WiFi signal strength
  - platform: wifi_signal
    name: "WiFi Signal"
    update_interval: 60s
    icon: "mdi:wifi"

# Binary sensors
binary_sensor:
  # Button for BLE Improv authorization (ATOM S3 button on GPIO41)
  - platform: gpio
    pin:
      number: GPIO41
      inverted: true
      mode: INPUT_PULLUP
    name: "Setup Button"
    id: setup_button
    filters:
      - delayed_on: 10ms
      - delayed_off: 10ms

  - platform: template
    name: "Sensor Out of Range"
    id: sensor_out_of_range
    icon: "mdi:alert-circle"
    lambda: |-
      // VL53L0X sensor hardware limits
      const float SENSOR_MIN_RANGE = 3.0;   // cm
      const float SENSOR_MAX_RANGE = 150.0; // cm

      float tank_height = id(tank_height_cm).state;
      float full_level = id(full_level_cm).state;
      float current_distance = id(salt_distance_raw).state;

      // Check if reading is invalid
      if (isnan(current_distance) || isnan(tank_height) || isnan(full_level)) {
        return true;
      } else if (current_distance < SENSOR_MIN_RANGE) {
        return true;
      } else if (current_distance > SENSOR_MAX_RANGE) {
        return true;
      }
      return false;  // Valid reading

  - platform: template
    name: "Regeneration Cycle Active"
    id: regen_cycle_active
    icon: "mdi:water-sync"
    lambda: |-
      float current_level = id(salt_level_percent).state;
      unsigned long current_time = millis();

      // Skip if invalid reading
      if (isnan(current_level)) {
        return id(regen_active);
      }

      // Maintain rolling window of recent readings for stability check
      if (id(recent_readings).size() >= 6) {
        id(recent_readings).erase(id(recent_readings).begin());
      }
      id(recent_readings).push_back(current_level);

      // === START DETECTION ===
      if (!id(regen_active)) {
        // Check for sudden drop indicating regen start
        // Method 1: >3% drop in 5 minutes (1 sample at 5-min intervals)
        // Method 2: >5% drop in 10 minutes (2 samples)

        bool start_detected = false;

        if (id(recent_readings).size() >= 2) {
          // Check 5-minute drop (current vs 1 sample ago)
          float drop_5min = id(recent_readings)[id(recent_readings).size() - 2] - current_level;
          if (drop_5min > 3.0) {
            start_detected = true;
          }
        }

        if (!start_detected && id(recent_readings).size() >= 3) {
          // Check 10-minute drop (current vs 2 samples ago)
          float drop_10min = id(recent_readings)[id(recent_readings).size() - 3] - current_level;
          if (drop_10min > 5.0) {
            start_detected = true;
          }
        }

        if (start_detected) {
          // Regen cycle started!
          id(regen_active) = true;
          id(regen_baseline) = id(recent_readings)[0];  // Use oldest reading as baseline
          id(regen_start_time) = current_time;
          id(drop_amount) = id(regen_baseline) - current_level;
          ESP_LOGI("regen", "Regeneration started - baseline: %.1f%%, drop: %.1f%%",
                   id(regen_baseline), id(drop_amount));
        }
      }

      // === END DETECTION ===
      if (id(regen_active)) {
        unsigned long elapsed_seconds = (current_time - id(regen_start_time)) / 1000;
        unsigned long elapsed_minutes = elapsed_seconds / 60;
        float current_drop = id(regen_baseline) - current_level;

        // Safety timeout: 4 hours maximum
        if (elapsed_minutes > 240) {
          ESP_LOGI("regen", "Regeneration ended - timeout after %lu minutes", elapsed_minutes);
          id(regen_active) = false;
          id(recent_readings).clear();
          return false;
        }

        // False alarm reset: If <5% total drop after 1 hour
        if (elapsed_minutes > 60 && id(drop_amount) < 5.0) {
          ESP_LOGI("regen", "Regeneration ended - false alarm (only %.1f%% drop)", id(drop_amount));
          id(regen_active) = false;
          id(recent_readings).clear();
          return false;
        }

        // Check for end condition: 50% recovery + stability
        float recovery_target = id(regen_baseline) - (id(drop_amount) * 0.5);
        bool recovered = current_level >= recovery_target;

        if (recovered && id(recent_readings).size() >= 6) {
          // Check stability: Â±2% variation over last 30 minutes (6 samples)
          float min_level = *std::min_element(id(recent_readings).begin(), id(recent_readings).end());
          float max_level = *std::max_element(id(recent_readings).begin(), id(recent_readings).end());
          float variation = max_level - min_level;

          if (variation <= 2.0) {
            // Regeneration complete!
            ESP_LOGI("regen", "Regeneration ended - recovered and stable after %lu minutes", elapsed_minutes);
            id(regen_active) = false;
            id(recent_readings).clear();
            return false;
          }
        }

        // Update drop amount if current drop is larger
        if (current_drop > id(drop_amount)) {
          id(drop_amount) = current_drop;
        }
      }

      return id(regen_active);
    attributes:
      baseline_level:
        lambda: |-
          if (id(regen_active)) {
            return esphome::optional<float>(id(regen_baseline));
          }
          return {};
      drop_percentage:
        lambda: |-
          if (id(regen_active)) {
            return esphome::optional<float>(id(drop_amount));
          }
          return {};
      minutes_active:
        lambda: |-
          if (id(regen_active)) {
            unsigned long elapsed_ms = millis() - id(regen_start_time);
            return esphome::optional<unsigned long>(elapsed_ms / 60000);
          }
          return {};

# Status text
text_sensor:
  - platform: template
    name: "Salt Status"
    id: salt_status_text
    icon: "mdi:information-variant"
    update_interval: never  # Only updates when triggered
    lambda: |-
      // Freeze status during regeneration cycle
      if (id(regen_active)) {
        return {id(last_valid_status)};
      }

      float level = id(salt_level_percent).state;
      float full_threshold_val = id(full_threshold)->state;
      float good_threshold_val = id(good_threshold)->state;
      float low_threshold_val = id(low_threshold)->state;
      float critical_threshold_val = id(critical_threshold)->state;

      // Calculate what status should be based on current level
      std::string new_status;
      if (isnan(level)) {
        new_status = "Checking...";
      } else if (level >= full_threshold_val) {
        new_status = "Full";
      } else if (level >= good_threshold_val) {
        new_status = "Good";
      } else if (level >= low_threshold_val) {
        new_status = "Low - Add Salt Soon";
      } else if (level >= critical_threshold_val) {
        new_status = "Critical - Add Salt NOW!";
      } else {
        new_status = "Critical - Add Salt NOW!";
      }

      // 30-minute confirmation delay before changing status
      unsigned long current_time = millis();
      const unsigned long CONFIRMATION_DELAY = 1800000;  // 30 minutes in milliseconds

      if (new_status != id(last_valid_status)) {
        // Status wants to change
        if (id(pending_status) != new_status) {
          // New pending status, start timer
          id(pending_status) = new_status;
          id(pending_status_time) = current_time;
          return {id(last_valid_status)};  // Keep showing old status
        }

        // Check if enough time has passed
        if (current_time - id(pending_status_time) < CONFIRMATION_DELAY) {
          return {id(last_valid_status)};  // Still waiting for confirmation
        }
      }

      // Status confirmed stable, update it
      id(pending_status) = "";
      id(last_valid_status) = new_status;
      return {new_status};

# Fast update interval for calibration mode
interval:
  - interval: 100ms
    then:
      - if:
          condition:
            switch.is_on: calibration_mode
          then:
            - component.update: salt_distance_raw

  # Normal update interval check
  - interval: 1s
    then:
      - lambda: |-
          // Only run normal interval if NOT in calibration mode
          if (!id(calibration_mode).state) {
            unsigned long current_time = millis() / 1000;
            unsigned long interval_sec = (unsigned long)id(update_interval_seconds).state;

            if (current_time - id(last_update_time) >= interval_sec) {
              id(last_update_time) = current_time;
              id(salt_distance_raw).update();
            }
          }
