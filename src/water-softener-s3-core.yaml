# ESPHome Water Softener Salt Monitor - Simplified v0.3
# GitHub: https://github.com/rmaher001/water-softener-monitor
#
# Simple distance-based monitoring with basic Good/Refill status
# All advanced analytics handled in Home Assistant

esp32:
  board: m5stack-atoms3
  variant: esp32s3
  framework:
    type: esp-idf

# Preferences with debounced flash writes
preferences:
  flash_write_interval: 5s

# WiFi configuration moved to individual config files
captive_portal:

# Enable Improv via Serial for web installer WiFi configuration
improv_serial:

# Enable BLE Improv for wireless WiFi configuration
esp32_improv:
  authorizer: none

# Enable logging
logger:
  baud_rate: 115200
  deassert_rts_dtr: true  # Required for ESP32-S3 USB CDC compatibility

# Web server for standalone configuration
web_server:
  port: 80
  version: 3

# I2C for the ToF sensor (ATOM S3 Lite Grove port)
i2c:
  sda: GPIO2
  scl: GPIO1
  scan: true

# Global variables
globals:
  - id: last_valid_status
    type: std::string
    restore_value: yes
    initial_value: '"Checking..."'

  # Regeneration detection tracking
  - id: regen_active
    type: bool
    restore_value: no
    initial_value: 'false'

  - id: regen_baseline
    type: float
    restore_value: no
    initial_value: '0.0'

  - id: regen_start_time
    type: unsigned long
    restore_value: no
    initial_value: '0'

  - id: drop_amount
    type: float
    restore_value: no
    initial_value: '0.0'

  - id: recent_readings
    type: std::vector<float>
    restore_value: no

# Configurable settings
number:
  - platform: template
    name: "Tank Height"
    id: tank_height_cm
    entity_category: "config"
    optimistic: true
    restore_value: true
    initial_value: 100
    min_value: 30
    max_value: 150
    step: 1
    unit_of_measurement: "cm"
    icon: "mdi:arrow-expand-vertical"
    mode: box

  - platform: template
    name: "Refill Threshold Distance"
    id: refill_threshold_cm
    entity_category: "config"
    optimistic: true
    restore_value: true
    initial_value: 43
    min_value: 10
    max_value: 120
    step: 1
    unit_of_measurement: "cm"
    icon: "mdi:arrow-expand-down"
    mode: box

  - platform: template
    name: "Update Interval"
    id: update_interval_seconds
    entity_category: "config"
    optimistic: true
    restore_value: true
    initial_value: 60
    min_value: 30
    max_value: 300
    step: 30
    unit_of_measurement: "s"
    icon: "mdi:timer-outline"
    mode: box

# Switches
switch:
  - platform: template
    name: "Fast Polling Mode"
    id: fast_polling_mode
    icon: "mdi:speedometer"
    optimistic: true
    on_turn_on:
      - delay: 300s  # Auto-disable after 5 minutes
      - switch.turn_off: fast_polling_mode

# Buttons
button:
  - platform: template
    name: "Set Default Thresholds"
    id: set_default_thresholds
    icon: "mdi:auto-fix"
    on_press:
      - lambda: |-
          float tank_height = id(tank_height_cm).state;
          float new_threshold = tank_height * 0.43;
          id(refill_threshold_cm).publish_state(new_threshold);
          ESP_LOGI("config", "Default thresholds set: threshold=%.1fcm (43%% of %.0fcm tank height)", new_threshold, tank_height);

  - platform: restart
    name: "Restart"
    icon: "mdi:restart"

# VL53L0X Distance Sensor
sensor:
  - platform: vl53l0x
    name: "Distance to Salt"
    id: salt_distance_raw
    address: 0x29
    update_interval: never  # Controlled by interval component
    long_range: true
    unit_of_measurement: "cm"
    accuracy_decimals: 1
    filters:
      - multiply: 100  # Convert meters to cm
      - filter_out: nan
      - clamp:
          min_value: 5.0
          max_value: 120.0
          ignore_out_of_range: true
      - median:
          window_size: 3
          send_every: 1
    on_value:
      then:
        - component.update: salt_status_text

  # WiFi signal strength
  - platform: wifi_signal
    name: "WiFi Signal"
    update_interval: 60s
    icon: "mdi:wifi"

# Binary sensors
binary_sensor:
  - platform: template
    name: "Sensor Out of Range"
    id: sensor_out_of_range
    icon: "mdi:alert-circle"
    lambda: |-
      const float SENSOR_MIN_RANGE = 5.0;   // cm
      const float SENSOR_MAX_RANGE = 120.0; // cm
      float current_distance = id(salt_distance_raw).state;

      if (isnan(current_distance)) {
        return true;
      } else if (current_distance < SENSOR_MIN_RANGE || current_distance > SENSOR_MAX_RANGE) {
        return true;
      }
      return false;

  - platform: template
    name: "Regeneration Cycle Active"
    id: regen_cycle_active
    icon: "mdi:water-sync"
    lambda: |-
      // Regeneration detection configuration constants
      const float REGEN_RISE_SHORT_CM = 3.0;       // Rise threshold for short window (5 readings)
      const float REGEN_RISE_LONG_CM = 5.0;        // Rise threshold for long window (10 readings)
      const float REGEN_FALSE_ALARM_CM = 5.0;      // Minimum total rise to not be false alarm
      const size_t REGEN_ROLLING_WINDOW_SIZE = 60; // Number of readings to keep in history
      const unsigned long REGEN_TIMEOUT_MINUTES = 240;  // 4 hours max duration
      const unsigned long REGEN_FALSE_ALARM_MINUTES = 60; // Time before false alarm check
      const size_t REGEN_STABILITY_WINDOW_SIZE = 30;    // Readings needed for stability check
      const float REGEN_STABILITY_VARIATION_CM = 2.0;   // Max variation for stability
      const float REGEN_RECOVERY_THRESHOLD = 0.5;  // 50% recovery from baseline to end cycle

      float current_distance = id(salt_distance_raw).state;
      unsigned long current_time = millis();

      if (isnan(current_distance)) {
        return id(regen_active);
      }

      // === START DETECTION ===
      if (!id(regen_active)) {
        bool start_detected = false;

        // Check for >3cm rise over last 5 readings
        // (Faster detection at shorter update intervals, still works at longer intervals)
        if (id(recent_readings).size() >= 5) {
          float rise_5readings = current_distance - id(recent_readings)[id(recent_readings).size() - 5];
          if (rise_5readings > REGEN_RISE_SHORT_CM) {
            start_detected = true;
            ESP_LOGD("regen", "Rise over 5 readings: %.1fcm", rise_5readings);
          }
        }

        // Check for >5cm rise over last 10 readings (catches slower/gradual rises)
        if (!start_detected && id(recent_readings).size() >= 10) {
          float rise_10readings = current_distance - id(recent_readings)[id(recent_readings).size() - 10];
          if (rise_10readings > REGEN_RISE_LONG_CM) {
            start_detected = true;
            ESP_LOGD("regen", "Rise over 10 readings: %.1fcm", rise_10readings);
          }
        }

        if (start_detected) {
          id(regen_active) = true;
          id(regen_baseline) = id(recent_readings).front();
          id(regen_start_time) = current_time;
          id(drop_amount) = current_distance - id(regen_baseline);
          ESP_LOGI("regen", "Regeneration started - baseline: %.1fcm, rise: %.1fcm",
                   id(regen_baseline), id(drop_amount));
        }
      }

      // Maintain rolling window of recent readings
      // Provides sufficient history for rise detection and stability checks
      if (id(recent_readings).size() >= REGEN_ROLLING_WINDOW_SIZE) {
        id(recent_readings).erase(id(recent_readings).begin());
      }
      id(recent_readings).push_back(current_distance);

      // === END DETECTION ===
      if (id(regen_active)) {
        unsigned long elapsed_seconds = (current_time - id(regen_start_time)) / 1000;
        unsigned long elapsed_minutes = elapsed_seconds / 60;
        float current_rise = current_distance - id(regen_baseline);

        // Safety timeout: 4 hours
        if (elapsed_minutes > REGEN_TIMEOUT_MINUTES) {
          ESP_LOGI("regen", "Regeneration ended - timeout after %lu minutes", elapsed_minutes);
          id(regen_active) = false;
          id(recent_readings).clear();
          return false;
        }

        // False alarm reset: Insufficient rise after prolonged time
        if (elapsed_minutes > REGEN_FALSE_ALARM_MINUTES && id(drop_amount) < REGEN_FALSE_ALARM_CM) {
          ESP_LOGI("regen", "Regeneration ended - false alarm (only %.1fcm rise)", id(drop_amount));
          id(regen_active) = false;
          id(recent_readings).clear();
          return false;
        }

        // End condition: Two possible patterns
        // Pattern 1 (poorly maintained): Distance rises then recovers back down
        // Pattern 2 (well-maintained): Distance rises and stays at new level

        bool end_cycle = false;

        if (id(recent_readings).size() >= REGEN_STABILITY_WINDOW_SIZE) {
          float min_distance = *std::min_element(id(recent_readings).begin(), id(recent_readings).end());
          float max_distance = *std::max_element(id(recent_readings).begin(), id(recent_readings).end());
          float variation = max_distance - min_distance;
          bool is_stable = variation <= REGEN_STABILITY_VARIATION_CM;

          if (is_stable) {
            // Check if distance recovered back down (poorly maintained pattern)
            float recovery_target = id(regen_baseline) + (id(drop_amount) * REGEN_RECOVERY_THRESHOLD);
            bool recovered = current_distance <= recovery_target;

            if (recovered) {
              ESP_LOGI("regen", "Regeneration ended - recovered and stable after %lu minutes", elapsed_minutes);
              end_cycle = true;
            } else {
              // Distance is stable but hasn't recovered = well-maintained pattern
              // Distance rose and stayed at new level
              ESP_LOGI("regen", "Regeneration ended - stable at new level after %lu minutes", elapsed_minutes);
              end_cycle = true;
            }
          }
        }

        if (end_cycle) {
          id(regen_active) = false;
          id(recent_readings).clear();
          return false;
        }

        if (current_rise > id(drop_amount)) {
          id(drop_amount) = current_rise;
        }
      }

      return id(regen_active);

# Status text
text_sensor:
  - platform: template
    name: "Salt Status"
    id: salt_status_text
    icon: "mdi:information-variant"
    update_interval: never
    lambda: |-
      // Status hysteresis configuration
      const float STATUS_HYSTERESIS_CM = 2.0;  // Dead zone to prevent status bouncing

      // Freeze status during regeneration cycle
      if (id(regen_active)) {
        return {id(last_valid_status)};
      }

      float distance = id(salt_distance_raw).state;
      float threshold = id(refill_threshold_cm).state;

      std::string new_status;
      std::string current_status = id(last_valid_status);

      if (isnan(distance)) {
        new_status = "Checking...";
      } else {
        // First boot: Initialize status directly without hysteresis
        if (current_status == "Checking...") {
          new_status = (distance >= threshold) ? "Refill" : "Good";
        }
        // Apply hysteresis based on current status
        else if (current_status == "Good") {
          // Need to exceed threshold + hysteresis to change to Refill
          if (distance >= (threshold + STATUS_HYSTERESIS_CM)) {
            new_status = "Refill";
          } else {
            new_status = "Good";
          }
        } else {
          // Currently "Refill" - need to drop below threshold - hysteresis for Good
          if (distance < (threshold - STATUS_HYSTERESIS_CM)) {
            new_status = "Good";
          } else {
            new_status = "Refill";
          }
        }
      }

      // Log status changes
      if (new_status != current_status) {
        ESP_LOGI("status", "Status change: %s -> %s", current_status.c_str(), new_status.c_str());
      }

      id(last_valid_status) = new_status;
      return {new_status};

  - platform: template
    name: "Firmware Version"
    icon: "mdi:chip"
    lambda: |-
      return {"${version}"};

# Update intervals
interval:
  # Fast polling for setup/calibration
  - interval: 100ms
    then:
      - if:
          condition:
            switch.is_on: fast_polling_mode
          then:
            - component.update: salt_distance_raw

  # Normal update interval
  - interval: 1s
    then:
      - lambda: |-
          static unsigned long last_update = 0;
          unsigned long current_time = millis() / 1000;
          unsigned long interval_sec = (unsigned long)id(update_interval_seconds).state;

          if (!id(fast_polling_mode).state && (current_time - last_update >= interval_sec)) {
            last_update = current_time;
            id(salt_distance_raw).update();
          }

# On boot - take immediate reading
esphome:
  on_boot:
    priority: -100  # After other components initialized
    then:
      - delay: 2s  # Wait for sensor to stabilize
      - component.update: salt_distance_raw
