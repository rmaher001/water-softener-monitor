# ESPHome Water Softener Salt Monitor - v0.4.0 (ATOM Lite)
# GitHub: https://github.com/rmaher001/water-softener-monitor
#
# Simple distance-based monitoring with derivative-based regeneration detection
# All advanced analytics handled in Home Assistant

# ATOM Lite board configuration
esp32:
  board: m5stack-atom
  framework:
    type: esp-idf

# Preferences with debounced flash writes
preferences:
  flash_write_interval: 5s

# Enable logging
logger:
  baud_rate: 115200

# WiFi configuration moved to webinstall config files
captive_portal:

# Web server for standalone configuration
web_server:
  port: 80
  version: 3

# Enable Improv via Serial for web installer WiFi configuration
improv_serial:

# Enable BLE Improv for wireless WiFi configuration
esp32_improv:
  authorizer: none

# I2C for the ToF sensor (ATOM Lite Grove port)
i2c:
  sda: GPIO26
  scl: GPIO32
  scan: true

# Global variables
globals:
  - id: last_valid_status
    type: std::string
    restore_value: yes
    initial_value: '"Checking..."'

  # Derivative-based regeneration detection tracking
  - id: regen_active
    type: bool
    restore_value: no
    initial_value: 'false'

  - id: regen_start_time
    type: unsigned long
    restore_value: no
    initial_value: '0'

  # Store recent readings with timestamps for derivative calculation
  - id: recent_readings
    type: std::vector<float>
    restore_value: no

  - id: recent_timestamps
    type: std::vector<unsigned long>
    restore_value: no

  # Derivative tracking for start/end detection
  - id: rise_counter
    type: int
    restore_value: no
    initial_value: '0'

  - id: stable_counter
    type: int
    restore_value: no
    initial_value: '0'

# Configurable settings
number:
  - platform: template
    name: "Tank Height"
    id: tank_height_cm
    entity_category: "config"
    optimistic: true
    restore_value: true
    initial_value: 100
    min_value: 30
    max_value: 150
    step: 1
    unit_of_measurement: "cm"
    icon: "mdi:arrow-expand-vertical"
    mode: box

  - platform: template
    name: "Refill Threshold Distance"
    id: refill_threshold_cm
    entity_category: "config"
    optimistic: true
    restore_value: true
    initial_value: 43
    min_value: 10
    max_value: 120
    step: 1
    unit_of_measurement: "cm"
    icon: "mdi:arrow-expand-down"
    mode: box

  - platform: template
    name: "Update Interval"
    id: update_interval_seconds
    entity_category: "config"
    optimistic: true
    restore_value: true
    initial_value: 60
    min_value: 30
    max_value: 300
    step: 30
    unit_of_measurement: "s"
    icon: "mdi:timer-outline"
    mode: box

  - platform: template
    name: "Regen Detection Rise Threshold"
    id: regen_rise_threshold
    entity_category: "config"
    optimistic: true
    restore_value: true
    initial_value: 0.03
    min_value: 0.01
    max_value: 0.20
    step: 0.01
    unit_of_measurement: "cm/min"
    icon: "mdi:chart-line-variant"
    mode: box

  - platform: template
    name: "Regen Detection Stable Threshold"
    id: regen_stable_threshold
    entity_category: "config"
    optimistic: true
    restore_value: true
    initial_value: 0.015
    min_value: 0.005
    max_value: 0.10
    step: 0.005
    unit_of_measurement: "cm/min"
    icon: "mdi:chart-line"
    mode: box

  - platform: template
    name: "Regen Minimum Duration"
    id: regen_min_duration
    entity_category: "config"
    optimistic: true
    restore_value: true
    initial_value: 10
    min_value: 1
    max_value: 30
    step: 1
    unit_of_measurement: "min"
    icon: "mdi:timer-outline"
    mode: box

# Switches
switch:
  - platform: template
    name: "Fast Polling Mode"
    id: fast_polling_mode
    icon: "mdi:speedometer"
    optimistic: true
    on_turn_on:
      - delay: 300s  # Auto-disable after 5 minutes
      - switch.turn_off: fast_polling_mode

# Buttons
button:
  - platform: template
    name: "Set Default Thresholds"
    id: set_default_thresholds
    icon: "mdi:auto-fix"
    on_press:
      - lambda: |-
          float tank_height = id(tank_height_cm).state;
          float new_threshold = tank_height * 0.43;
          id(refill_threshold_cm).publish_state(new_threshold);
          ESP_LOGI("config", "Default thresholds set: threshold=%.1fcm (43%% of %.0fcm tank height)", new_threshold, tank_height);

  - platform: restart
    name: "Restart"
    icon: "mdi:restart"

# VL53L0X Distance Sensor
sensor:
  - platform: vl53l0x
    name: "Distance to Salt"
    id: salt_distance_raw
    address: 0x29
    update_interval: never  # Controlled by interval component
    long_range: true
    unit_of_measurement: "cm"
    accuracy_decimals: 1
    filters:
      - multiply: 100  # Convert meters to cm
      - filter_out: nan
      - clamp:
          min_value: 5.0
          max_value: 120.0
          ignore_out_of_range: true
      - median:
          window_size: 3
          send_every: 1
    on_value:
      then:
        - component.update: salt_status_text

  # WiFi signal strength
  - platform: wifi_signal
    name: "WiFi Signal"
    update_interval: 60s
    icon: "mdi:wifi"

# Binary sensors
binary_sensor:
  - platform: template
    name: "Sensor Out of Range"
    id: sensor_out_of_range
    icon: "mdi:alert-circle"
    lambda: |-
      const float SENSOR_MIN_RANGE = 5.0;   // cm
      const float SENSOR_MAX_RANGE = 120.0; // cm
      float current_distance = id(salt_distance_raw).state;

      if (isnan(current_distance)) {
        return true;
      } else if (current_distance < SENSOR_MIN_RANGE || current_distance > SENSOR_MAX_RANGE) {
        return true;
      }
      return false;

  - platform: template
    name: "Regeneration Cycle Active"
    id: regen_cycle_active
    icon: "mdi:water-sync"
    lambda: |-
      // Derivative-based regeneration detection
      // Detects sustained rate of change (derivative) rather than absolute thresholds
      const unsigned long REGEN_TIMEOUT_MINUTES = 240;  // 4 hours max duration (safety)
      const size_t DERIVATIVE_WINDOW_SIZE = 15;          // Keep last 15 readings for derivative calc
      const size_t DERIVATIVE_START_CONFIRM = 3;         // Confirm rise over 3 consecutive derivatives
      const size_t DERIVATIVE_END_CONFIRM = 10;          // Confirm stable over 10 consecutive derivatives

      float current_distance = id(salt_distance_raw).state;
      unsigned long current_time = millis();

      // Skip processing if sensor reading is invalid
      if (isnan(current_distance)) {
        return id(regen_active);
      }

      // Get configurable thresholds from UI
      float rise_threshold = id(regen_rise_threshold).state;      // cm/min
      float stable_threshold = id(regen_stable_threshold).state;  // cm/min
      unsigned long min_duration_ms = (unsigned long)(id(regen_min_duration).state * 60000);  // Convert min to ms

      // Maintain rolling window of readings and timestamps
      if (id(recent_readings).size() >= DERIVATIVE_WINDOW_SIZE) {
        id(recent_readings).erase(id(recent_readings).begin());
        id(recent_timestamps).erase(id(recent_timestamps).begin());
      }
      id(recent_readings).push_back(current_distance);
      id(recent_timestamps).push_back(current_time);

      // Need at least 2 readings to calculate derivative
      if (id(recent_readings).size() < 2) {
        return id(regen_active);
      }

      // Calculate derivative (rate of change in cm/min)
      size_t n = id(recent_readings).size();
      float distance_delta = id(recent_readings)[n-1] - id(recent_readings)[n-2];
      unsigned long time_delta_ms = id(recent_timestamps)[n-1] - id(recent_timestamps)[n-2];
      float time_delta_min = time_delta_ms / 60000.0;  // Convert ms to minutes
      float derivative = (time_delta_min > 0) ? (distance_delta / time_delta_min) : 0;

      // === START DETECTION ===
      if (!id(regen_active)) {
        // Check if derivative indicates sustained rise
        if (derivative > rise_threshold) {
          id(rise_counter) = id(rise_counter) + 1;
          id(stable_counter) = 0;  // Reset stable counter
        } else {
          id(rise_counter) = 0;  // Reset rise counter if derivative drops
        }

        // Start detection if sustained rise confirmed
        if (id(rise_counter) >= DERIVATIVE_START_CONFIRM) {
          id(regen_active) = true;
          id(regen_start_time) = current_time;
          id(rise_counter) = 0;
          id(stable_counter) = 0;
          ESP_LOGI("regen", "Regeneration started - derivative: %.3f cm/min (threshold: %.3f)",
                   derivative, rise_threshold);
        }
      }

      // === END DETECTION ===
      if (id(regen_active)) {
        unsigned long elapsed_ms = current_time - id(regen_start_time);
        unsigned long elapsed_min = elapsed_ms / 60000;

        // Safety timeout: 4 hours maximum
        if (elapsed_min > REGEN_TIMEOUT_MINUTES) {
          ESP_LOGI("regen", "Regeneration ended - timeout after %lu minutes", elapsed_min);
          id(regen_active) = false;
          id(rise_counter) = 0;
          id(stable_counter) = 0;
          id(recent_readings).clear();
          id(recent_timestamps).clear();
          return false;
        }

        // False alarm: Cycle ended too quickly (noise/spike)
        if (elapsed_ms < min_duration_ms) {
          // Check if derivative indicates stable (near-zero rate of change)
          if (abs(derivative) < stable_threshold) {
            id(stable_counter) = id(stable_counter) + 1;
          } else {
            id(stable_counter) = 0;
          }

          // If stable too early, it was likely a false alarm
          if (id(stable_counter) >= DERIVATIVE_END_CONFIRM) {
            ESP_LOGI("regen", "Regeneration ended - false alarm (duration: %lu ms < %lu ms minimum)",
                     elapsed_ms, min_duration_ms);
            id(regen_active) = false;
            id(rise_counter) = 0;
            id(stable_counter) = 0;
            id(recent_readings).clear();
            id(recent_timestamps).clear();
            return false;
          }
        }
        // Normal end detection: sustained stable derivative
        else {
          // Check if derivative indicates stable (near-zero rate of change)
          if (abs(derivative) < stable_threshold) {
            id(stable_counter) = id(stable_counter) + 1;
            id(rise_counter) = 0;
          } else {
            id(stable_counter) = 0;
          }

          // End detection if sustained stability confirmed
          if (id(stable_counter) >= DERIVATIVE_END_CONFIRM) {
            ESP_LOGI("regen", "Regeneration ended - stable derivative after %lu minutes", elapsed_min);
            id(regen_active) = false;
            id(rise_counter) = 0;
            id(stable_counter) = 0;
            id(recent_readings).clear();
            id(recent_timestamps).clear();
            return false;
          }
        }
      }

      return id(regen_active);

# Status text
text_sensor:
  - platform: template
    name: "Salt Status"
    id: salt_status_text
    icon: "mdi:information-variant"
    update_interval: never
    lambda: |-
      // Status hysteresis configuration
      const float STATUS_HYSTERESIS_CM = 2.0;  // Dead zone to prevent status bouncing

      // Freeze status during regeneration cycle
      if (id(regen_active)) {
        return {id(last_valid_status)};
      }

      float distance = id(salt_distance_raw).state;
      float threshold = id(refill_threshold_cm).state;

      std::string new_status;
      std::string current_status = id(last_valid_status);

      if (isnan(distance)) {
        new_status = "Checking...";
      } else {
        // First boot: Initialize status directly without hysteresis
        if (current_status == "Checking...") {
          new_status = (distance >= threshold) ? "Refill" : "Good";
        }
        // Apply hysteresis based on current status
        else if (current_status == "Good") {
          // Need to exceed threshold + hysteresis to change to Refill
          if (distance >= (threshold + STATUS_HYSTERESIS_CM)) {
            new_status = "Refill";
          } else {
            new_status = "Good";
          }
        } else {
          // Currently "Refill" - need to drop below threshold - hysteresis for Good
          if (distance < (threshold - STATUS_HYSTERESIS_CM)) {
            new_status = "Good";
          } else {
            new_status = "Refill";
          }
        }
      }

      // Log status changes
      if (new_status != current_status) {
        ESP_LOGI("status", "Status change: %s -> %s", current_status.c_str(), new_status.c_str());
      }

      id(last_valid_status) = new_status;
      return {new_status};

  - platform: template
    name: "Firmware Version"
    icon: "mdi:chip"
    lambda: |-
      return {"${version}"};

# Update intervals
interval:
  # Fast polling for setup/calibration
  - interval: 100ms
    then:
      - if:
          condition:
            switch.is_on: fast_polling_mode
          then:
            - component.update: salt_distance_raw

  # Normal update interval
  - interval: 1s
    then:
      - lambda: |-
          static unsigned long last_update = 0;
          unsigned long current_time = millis() / 1000;
          unsigned long interval_sec = (unsigned long)id(update_interval_seconds).state;

          if (!id(fast_polling_mode).state && (current_time - last_update >= interval_sec)) {
            last_update = current_time;
            id(salt_distance_raw).update();
          }

# On boot - take immediate reading
esphome:
  on_boot:
    priority: -100  # After other components initialized
    then:
      - delay: 2s  # Wait for sensor to stabilize
      - component.update: salt_distance_raw
