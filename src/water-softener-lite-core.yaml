# ESPHome Water Softener Salt Monitor Package - ATOM Lite
# GitHub: https://github.com/rmaher001/water-softener-monitor
#
# Core package for ATOM Lite (ESP32-PICO-D4) hardware
# Features ESP-IDF framework with working web server and NVS persistence

# ATOM Lite board configuration
esp32:
  board: m5stack-atom
  framework:
    type: esp-idf

# Preferences with debounced flash writes
preferences:
  flash_write_interval: 5s

# Enable logging
logger:
  baud_rate: 115200

# WiFi configuration moved to webinstall config files

# Enable captive portal for WiFi setup (backup method)
captive_portal:

# Web server for standalone configuration (ESP-IDF supports this without socket exhaustion)
web_server:
  port: 80
  version: 3

# Enable Improv via Serial for web installer WiFi configuration
improv_serial:

# Enable BLE Improv for wireless WiFi configuration
# Uses 'none' authorizer - makes it easier for users during initial web installer setup
# Security comes from eventual ESPHome Dashboard adoption with encryption
esp32_improv:
  authorizer: none

# I2C for the ToF sensor (ATOM Lite Grove port)
i2c:
  sda: GPIO26
  scl: GPIO32
  scan: true

# RGB LED for button feedback (ATOM Lite built-in)
light:
  - platform: esp32_rmt_led_strip
    chipset: WS2812
    pin: GPIO27
    num_leds: 1
    rgb_order: GRB
    name: "Status LED"
    id: status_led
    internal: true

# Global variables
globals:
  - id: last_update_time
    type: unsigned long
    restore_value: no
    initial_value: '0'

  - id: last_valid_percentage
    type: float
    restore_value: yes
    initial_value: '0.0'

  - id: last_valid_status
    type: std::string
    restore_value: yes
    initial_value: '"Checking..."'

  # Manual refill tracking
  - id: last_manual_refill_time
    type: unsigned long
    restore_value: yes
    initial_value: '0'

  # Regeneration detection tracking
  - id: regen_active
    type: bool
    restore_value: no
    initial_value: 'false'

  - id: regen_baseline
    type: float
    restore_value: no
    initial_value: '0.0'

  - id: regen_start_time
    type: unsigned long
    restore_value: no
    initial_value: '0'

  - id: drop_amount
    type: float
    restore_value: no
    initial_value: '0.0'

  - id: recent_readings
    type: std::vector<float>
    restore_value: no

# Configurable settings
number:
  # Measurement settings
  - platform: template
    name: "Tank Height"
    id: tank_height_cm
    entity_category: "config"
    optimistic: true
    restore_value: true
    initial_value: 100
    min_value: 30
    max_value: 150
    step: 1
    unit_of_measurement: "cm"
    icon: "mdi:arrow-expand-vertical"
    mode: box
    on_value:
      then:
        - component.update: salt_level_percent

  - platform: template
    name: "Full Level Distance"
    id: full_level_cm
    entity_category: "config"
    optimistic: true
    restore_value: true
    initial_value: 20
    min_value: 5
    max_value: 50
    step: 1
    unit_of_measurement: "cm"
    icon: "mdi:arrow-collapse-down"
    mode: box
    on_value:
      then:
        - component.update: salt_level_percent

  - platform: template
    name: "Update Interval"
    id: update_interval_seconds
    entity_category: "config"
    optimistic: true
    restore_value: true
    initial_value: 300
    min_value: 1
    max_value: 86400
    step: 1
    unit_of_measurement: "s"
    icon: "mdi:timer"
    mode: box

  # Alert thresholds
  - platform: template
    name: "Critical Alert Threshold"
    id: critical_threshold
    entity_category: "config"
    optimistic: true
    restore_value: true
    initial_value: 20
    min_value: 0
    max_value: 100
    step: 5
    unit_of_measurement: "%"
    icon: "mdi:alert-octagon"
    mode: slider
    on_value:
      then:
        - component.update: salt_status_text

  - platform: template
    name: "Full Threshold"
    id: full_threshold
    entity_category: "config"
    optimistic: true
    restore_value: true
    initial_value: 80
    min_value: 0
    max_value: 100
    step: 5
    unit_of_measurement: "%"
    icon: "mdi:check-circle"
    mode: slider
    on_value:
      then:
        - component.update: salt_status_text

  - platform: template
    name: "Good Threshold"
    id: good_threshold
    entity_category: "config"
    optimistic: true
    restore_value: true
    initial_value: 60
    min_value: 0
    max_value: 100
    step: 5
    unit_of_measurement: "%"
    icon: "mdi:check"
    mode: slider
    on_value:
      then:
        - component.update: salt_status_text

  - platform: template
    name: "Low Alert Threshold"
    id: low_threshold
    entity_category: "config"
    optimistic: true
    restore_value: true
    initial_value: 40
    min_value: 0
    max_value: 100
    step: 5
    unit_of_measurement: "%"
    icon: "mdi:alert"
    mode: slider
    on_value:
      then:
        - component.update: salt_status_text

# Calibration mode switch
switch:
  - platform: template
    name: "Calibration Mode"
    id: calibration_mode
    icon: "mdi:ruler"
    optimistic: true
    on_turn_on:
      - delay: 300s  # 5 minutes
      - switch.turn_off: calibration_mode

# Buttons
button:
  - platform: template
    name: "Reset Thresholds to Defaults"
    icon: "mdi:restore"
    on_press:
      - number.set:
          id: full_threshold
          value: 80
      - delay: 100ms
      - number.set:
          id: good_threshold
          value: 60
      - delay: 100ms
      - number.set:
          id: low_threshold
          value: 40
      - delay: 100ms
      - number.set:
          id: critical_threshold
          value: 20

  - platform: restart
    name: "Restart"
    icon: "mdi:restart"

# VL53L0X Distance Sensor
sensor:
  - platform: vl53l0x
    name: "Distance to Salt"
    id: salt_distance_raw
    address: 0x29
    update_interval: never  # Controlled by interval component below
    long_range: true
    unit_of_measurement: "cm"
    accuracy_decimals: 1
    filters:
      - multiply: 100  # Convert meters to cm
      - filter_out: nan
      - median:
          window_size: 5
          send_every: 1
    on_value:
      then:
        - component.update: salt_level_percent
        - component.update: salt_status_text

  # Calculate salt level percentage
  - platform: template
    name: "Salt Level"
    id: salt_level_percent
    unit_of_measurement: "%"
    icon: "mdi:water-percent"
    accuracy_decimals: 0
    update_interval: never  # Only updates when triggered
    lambda: |-
      // VL53L0X sensor hardware limits
      const float SENSOR_MIN_RANGE = 3.0;   // cm
      const float SENSOR_MAX_RANGE = 150.0; // cm

      float tank_height = id(tank_height_cm).state;
      float full_level = id(full_level_cm).state;
      float current_distance = id(salt_distance_raw).state;

      // Check if sensor reading is valid
      bool is_valid = true;
      if (isnan(current_distance) || isnan(tank_height) || isnan(full_level)) {
        is_valid = false;
      } else if (current_distance < SENSOR_MIN_RANGE) {
        is_valid = false;
      } else if (current_distance > SENSOR_MAX_RANGE) {
        is_valid = false;
      }

      if (!is_valid) {
        // Return last valid value
        return id(last_valid_percentage);
      }

      // Calculate percentage
      float salt_height = tank_height - current_distance;
      float max_salt_height = tank_height - full_level;
      float percentage = (salt_height / max_salt_height) * 100.0;

      // Clamp to 0-100%
      if (percentage > 100.0) percentage = 100.0;
      if (percentage < 0.0) percentage = 0.0;

      // Store and return valid value
      id(last_valid_percentage) = percentage;
      return percentage;

  # WiFi signal strength
  - platform: wifi_signal
    name: "WiFi Signal"
    update_interval: 60s
    icon: "mdi:wifi"

# Binary sensors
binary_sensor:
  # Button for ATOM Lite (GPIO39 - does not support INPUT_PULLUP)
  - platform: gpio
    pin:
      number: GPIO39
      inverted: true
      mode: INPUT
    name: "Setup Button"
    id: setup_button
    filters:
      - delayed_on: 10ms
      - delayed_off: 10ms
    on_click:
      # Long press (3-5 seconds) = Manual refill confirmation
      - min_length: 3000ms
        max_length: 5000ms
        then:
          # Flash LED 3 times
          - repeat:
              count: 3
              then:
                - light.turn_on: status_led
                - delay: 200ms
                - light.turn_off: status_led
                - delay: 200ms

          # Record refill timestamp
          - lambda: |-
              id(last_manual_refill_time) = millis() / 1000;
              ESP_LOGI("refill", "Manual refill confirmed - distance: %.1fcm, level: %.1f%%",
                       id(salt_distance_raw).state, id(salt_level_percent).state);

          # LED solid for 2 seconds to confirm
          - light.turn_on: status_led
          - delay: 2000ms
          - light.turn_off: status_led

  - platform: template
    name: "Sensor Out of Range"
    id: sensor_out_of_range
    icon: "mdi:alert-circle"
    lambda: |-
      // VL53L0X sensor hardware limits
      const float SENSOR_MIN_RANGE = 3.0;   // cm
      const float SENSOR_MAX_RANGE = 150.0; // cm

      float tank_height = id(tank_height_cm).state;
      float full_level = id(full_level_cm).state;
      float current_distance = id(salt_distance_raw).state;

      // Check if reading is invalid
      if (isnan(current_distance) || isnan(tank_height) || isnan(full_level)) {
        return true;
      } else if (current_distance < SENSOR_MIN_RANGE) {
        return true;
      } else if (current_distance > SENSOR_MAX_RANGE) {
        return true;
      }
      return false;  // Valid reading

  - platform: template
    name: "Regeneration Cycle Active"
    id: regen_cycle_active
    icon: "mdi:water-sync"
    lambda: |-
      float current_level = id(salt_level_percent).state;
      unsigned long current_time = millis();

      // Skip if invalid reading
      if (isnan(current_level)) {
        return id(regen_active);
      }

      // Maintain rolling window of recent readings for stability check
      if (id(recent_readings).size() >= 6) {
        id(recent_readings).erase(id(recent_readings).begin());
      }
      id(recent_readings).push_back(current_level);

      // === START DETECTION ===
      if (!id(regen_active)) {
        // Check for sudden drop indicating regen start
        // Method 1: >3% drop in 5 minutes (1 sample at 5-min intervals)
        // Method 2: >5% drop in 10 minutes (2 samples)

        bool start_detected = false;

        if (id(recent_readings).size() >= 2) {
          // Check 5-minute drop (current vs 1 sample ago)
          float drop_5min = id(recent_readings)[id(recent_readings).size() - 2] - current_level;
          if (drop_5min > 3.0) {
            start_detected = true;
          }
        }

        if (!start_detected && id(recent_readings).size() >= 3) {
          // Check 10-minute drop (current vs 2 samples ago)
          float drop_10min = id(recent_readings)[id(recent_readings).size() - 3] - current_level;
          if (drop_10min > 5.0) {
            start_detected = true;
          }
        }

        if (start_detected) {
          // Regen cycle started!
          id(regen_active) = true;
          id(regen_baseline) = id(recent_readings)[0];  // Use oldest reading as baseline
          id(regen_start_time) = current_time;
          id(drop_amount) = id(regen_baseline) - current_level;
          ESP_LOGI("regen", "Regeneration started - baseline: %.1f%%, drop: %.1f%%",
                   id(regen_baseline), id(drop_amount));
        }
      }

      // === END DETECTION ===
      if (id(regen_active)) {
        unsigned long elapsed_seconds = (current_time - id(regen_start_time)) / 1000;
        unsigned long elapsed_minutes = elapsed_seconds / 60;
        float current_drop = id(regen_baseline) - current_level;

        // Safety timeout: 4 hours maximum
        if (elapsed_minutes > 240) {
          ESP_LOGI("regen", "Regeneration ended - timeout after %lu minutes", elapsed_minutes);
          id(regen_active) = false;
          id(recent_readings).clear();
          return false;
        }

        // False alarm reset: If <5% total drop after 1 hour
        if (elapsed_minutes > 60 && id(drop_amount) < 5.0) {
          ESP_LOGI("regen", "Regeneration ended - false alarm (only %.1f%% drop)", id(drop_amount));
          id(regen_active) = false;
          id(recent_readings).clear();
          return false;
        }

        // Check for end condition: 50% recovery + stability
        float recovery_target = id(regen_baseline) - (id(drop_amount) * 0.5);
        bool recovered = current_level >= recovery_target;

        if (recovered && id(recent_readings).size() >= 6) {
          // Check stability: Â±2% variation over last 30 minutes (6 samples)
          float min_level = *std::min_element(id(recent_readings).begin(), id(recent_readings).end());
          float max_level = *std::max_element(id(recent_readings).begin(), id(recent_readings).end());
          float variation = max_level - min_level;

          if (variation <= 2.0) {
            // Regeneration complete!
            ESP_LOGI("regen", "Regeneration ended - recovered and stable after %lu minutes", elapsed_minutes);
            id(regen_active) = false;
            id(recent_readings).clear();
            return false;
          }
        }

        // Update drop amount if current drop is larger
        if (current_drop > id(drop_amount)) {
          id(drop_amount) = current_drop;
        }
      }

      return id(regen_active);

# Status text
text_sensor:
  - platform: template
    name: "Salt Status"
    id: salt_status_text
    icon: "mdi:information-variant"
    update_interval: never  # Only updates when triggered
    lambda: |-
      // Freeze status during regeneration cycle
      if (id(regen_active)) {
        return {id(last_valid_status)};
      }

      float level = id(salt_level_percent).state;

      // Calculate what status should be based on current level
      std::string new_status;
      if (isnan(level)) {
        new_status = "Checking...";
      } else if (level >= id(full_threshold)->state) {
        new_status = "Full";
      } else if (level >= id(good_threshold)->state) {
        new_status = "Good";
      } else if (level >= id(low_threshold)->state) {
        new_status = "Low - Add Salt Soon";
      } else {
        new_status = "Critical - Add Salt NOW!";
      }

      // Rank statuses (higher = better)
      int rank_current = 0, rank_new = 0;
      if (id(last_valid_status) == "Full") rank_current = 3;
      else if (id(last_valid_status) == "Good") rank_current = 2;
      else if (id(last_valid_status) == "Low - Add Salt Soon") rank_current = 1;

      if (new_status == "Full") rank_new = 3;
      else if (new_status == "Good") rank_new = 2;
      else if (new_status == "Low - Add Salt Soon") rank_new = 1;

      // HYSTERESIS: Status can only improve if refill occurred in last 24 hours
      if (rank_new > rank_current) {
        unsigned long hrs_since_refill = (millis()/1000 - id(last_manual_refill_time)) / 3600;
        if (hrs_since_refill > 24) {
          // Keep current status, don't improve
          return {id(last_valid_status)};
        }
      }

      // Update status immediately (no confirmation delay)
      id(last_valid_status) = new_status;
      return {new_status};

  - platform: template
    name: "Firmware Version"
    icon: "mdi:chip"
    lambda: |-
      return {"${version}"};

# Fast update interval for calibration mode
interval:
  - interval: 100ms
    then:
      - if:
          condition:
            switch.is_on: calibration_mode
          then:
            - component.update: salt_distance_raw

  # Normal update interval check
  - interval: 1s
    then:
      - lambda: |-
          // Only run normal interval if NOT in calibration mode
          if (!id(calibration_mode).state) {
            unsigned long current_time = millis() / 1000;
            unsigned long interval_sec = (unsigned long)id(update_interval_seconds).state;

            if (current_time - id(last_update_time) >= interval_sec) {
              id(last_update_time) = current_time;
              id(salt_distance_raw).update();
            }
          }
